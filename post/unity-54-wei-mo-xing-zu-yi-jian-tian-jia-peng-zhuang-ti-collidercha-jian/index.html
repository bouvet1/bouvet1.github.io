<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Unity 5.4 为模型组一键添加碰撞体(Collider)插件 | Bouvet</title>
<link rel="shortcut icon" href="https://bouvet1.github.io/favicon.ico?v=1577950100550">
<link href="https://cdn.remixicon.com/releases/v2.1.0/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://bouvet1.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Unity 5.4 为模型组一键添加碰撞体(Collider)插件 | Bouvet - Atom Feed" href="https://bouvet1.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="效果图：

插件下载地址：
https://github.com/baishuisr1/Unity-Add-Game-group-Collider-Plugin
源码:
using System;
using UnityEngine;
us..." />
    <meta name="keywords" content="Unity" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://bouvet1.github.io">
  <img class="avatar" src="https://bouvet1.github.io/images/avatar.png?v=1577950100550" alt="">
  </a>
  <h1 class="site-title">
    Bouvet
  </h1>
  <p class="site-description">
    至繁归于至简
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Unity 5.4 为模型组一键添加碰撞体(Collider)插件
            </h2>
            <div class="post-info">
              <span>
                2017-08-18
              </span>
              <span>
                5 min read
              </span>
              
                <a href="https://bouvet1.github.io/tag/C7cY_GUuL" class="post-tag">
                  # Unity
                </a>
              
            </div>
            
              <img class="post-feature-image" src="http://upload-images.jianshu.io/upload_images/101711-16430da342436f83.gif?imageMogr2/auto-orient/strip" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>效果图：<br>
<img src="http://upload-images.jianshu.io/upload_images/101711-16430da342436f83.gif?imageMogr2/auto-orient/strip" alt="" loading="lazy"></p>
<p>插件下载地址：<br>
https://github.com/baishuisr1/Unity-Add-Game-group-Collider-Plugin</p>
<p>源码:</p>
<pre><code>using System;
using UnityEngine;
using UnityEditor;

public class AddCollider : EditorWindow
{
    [MenuItem(&quot;Window/辅助功能&quot;)]
    static void Window()
    {
        AddCollider newWindow = EditorWindow.GetWindow&lt;AddCollider&gt;(&quot;辅助功能&quot;);
        newWindow.Show();
    }


    private string zoom = &quot;100&quot;;

    void OnGUI()
    {
        GUILayout.Label(&quot;碰撞器缩放_百分比(默认100%)&quot;);
        zoom = GUILayout.TextField(zoom);
        if (GUILayout.Button(&quot;添加碰撞体积&quot;))
        {
            float zoomFloat = Convert.ToSingle(zoom)/100;
            if (zoomFloat &gt; 1.5)
            {
                Debug.Log(&quot;请输入1-150的数&quot;);
                return;
            }
            if (zoomFloat &lt; 0.1)
            {
                Debug.Log(&quot;请输入1-150的数&quot;);
                return;
            }
            GameObject gameObject = Selection.activeGameObject;
            if (gameObject == null)
            {
                Debug.Log(&quot;请选择一个物体&quot;);
                return;
            }

            Vector3 vector3;
            vector3 = gameObject.transform.position;
            gameObject.transform.position =new Vector3(0,0,0);

            float Y_Max = -5000;
            float Y_Mix = 5000;

            float X_Max = -5000;
            float X_Mix = 5000;

            float Z_Max = -5000;
            float Z_Mix = 5000;

            foreach (Transform VARIABLE in gameObject.transform)
            {
                BoxCollider boxCollider = VARIABLE.transform.gameObject.AddComponent&lt;BoxCollider&gt;();
                Vector3[] vector3s = GetBoxColliderVertexPositions(boxCollider);
                for (int i = 0; i &lt; vector3s.Length; i++)
                {
                    if (vector3s[i].y &gt;= Y_Max)
                    {
                        Y_Max = vector3s[i].y;
                    }

                    if (vector3s[i].y &lt;= Y_Mix)
                    {
                        Y_Mix = vector3s[i].y;
                    }

                    if (vector3s[i].x &gt;= X_Max)
                    {
                        X_Max = vector3s[i].x;
                    }

                    if (vector3s[i].x &lt;= X_Mix)
                    {
                        X_Mix = vector3s[i].x;
                    }

                    if (vector3s[i].z &gt;= Z_Max)
                    {
                        Z_Max = vector3s[i].z;
                    }

                    if (vector3s[i].z &lt;= Z_Mix)
                    {
                        Z_Mix = vector3s[i].z;
                    }
                }
            }


            Y_Max *= zoomFloat;
            Y_Mix *= zoomFloat;

            X_Max *= zoomFloat;
            X_Mix *= zoomFloat;

            Z_Max *= zoomFloat;
            Z_Mix *= zoomFloat;


            gameObject.AddComponent&lt;MeshCollider&gt;();
            Mesh mesh = new Mesh();
            mesh.name = gameObject.name;
            int[] triangles = new int[36];
            Vector3[] vertices = new Vector3[24];

            Vector3 verticeUp1 = new Vector3(X_Mix, Y_Max, Z_Max);
            vertices[3] = verticeUp1;
            vertices[9] = verticeUp1;
            vertices[21] = verticeUp1;
            Vector3 verticeUp2 = new Vector3(X_Mix, Y_Max, Z_Mix);
            vertices[5] = verticeUp2;
            vertices[11] = verticeUp2;
            vertices[20] = verticeUp2;
            Vector3 verticeUp3 = new Vector3(X_Max, Y_Max, Z_Mix);
            vertices[4] = verticeUp3;
            vertices[10] = verticeUp3;
            vertices[18] = verticeUp3;
            Vector3 verticeUp4 = new Vector3(X_Max, Y_Max, Z_Max);
            vertices[2] = verticeUp4;
            vertices[8] = verticeUp4;
            vertices[19] = verticeUp4;

            Vector3 verticeDown1 = new Vector3(X_Max, Y_Mix, Z_Max);
            vertices[0] = verticeDown1;
            vertices[14] = verticeDown1;
            vertices[17] = verticeDown1;
            Vector3 verticeDown2 = new Vector3(X_Mix, Y_Mix, Z_Max);
            vertices[1] = verticeDown2;
            vertices[15] = verticeDown2;
            vertices[23] = verticeDown2;
            Vector3 verticeDown3 = new Vector3(X_Mix, Y_Mix, Z_Mix);
            vertices[7] = verticeDown3;
            vertices[13] = verticeDown3;
            vertices[22] = verticeDown3;
            Vector3 verticeDown4 = new Vector3(X_Max, Y_Mix, Z_Mix);
            vertices[6] = verticeDown4;
            vertices[12] = verticeDown4;
            vertices[16] = verticeDown4;

            int currentCount = 0;
            for (int i = 0; i &lt; 24; i = i + 4)
            {
                //三角形1
                triangles[currentCount++] = i;
                triangles[currentCount++] = i + 3;
                triangles[currentCount++] = i + 1;
                //三角形2        
                triangles[currentCount++] = i;
                triangles[currentCount++] = i + 2;
                triangles[currentCount++] = i + 3;
            }

            mesh.vertices = vertices;
            mesh.triangles = triangles;
            gameObject.GetComponent&lt;MeshCollider&gt;().sharedMesh = mesh;

            foreach (Transform VARIABLE in gameObject.transform)
            {
                DestroyImmediate(VARIABLE.GetComponent&lt;BoxCollider&gt;());
            }
            gameObject.transform.position = vector3;
        }
    }

    Vector3[] GetBoxColliderVertexPositions(BoxCollider boxcollider)
    {
        var vertices = new Vector3[8];
        
        vertices[0] =
            boxcollider.transform.TransformPoint(boxcollider.center +
                                                 new Vector3(boxcollider.size.x, -boxcollider.size.y, boxcollider.size.z)*
                                                 0.5f);
        vertices[1] =
            boxcollider.transform.TransformPoint(boxcollider.center +
                                                 new Vector3(-boxcollider.size.x, -boxcollider.size.y,
                                                     boxcollider.size.z)*0.5f);
        vertices[2] =
            boxcollider.transform.TransformPoint(boxcollider.center +
                                                 new Vector3(-boxcollider.size.x, -boxcollider.size.y,
                                                     -boxcollider.size.z)*0.5f);
        vertices[3] =
            boxcollider.transform.TransformPoint(boxcollider.center +
                                                 new Vector3(boxcollider.size.x, -boxcollider.size.y,
                                                     -boxcollider.size.z)*0.5f);
        
        vertices[4] =
            boxcollider.transform.TransformPoint(boxcollider.center +
                                                 new Vector3(boxcollider.size.x, boxcollider.size.y, boxcollider.size.z)*
                                                 0.5f);
        vertices[5] =
            boxcollider.transform.TransformPoint(boxcollider.center +
                                                 new Vector3(-boxcollider.size.x, boxcollider.size.y, boxcollider.size.z)*
                                                 0.5f);
        vertices[6] =
            boxcollider.transform.TransformPoint(boxcollider.center +
                                                 new Vector3(-boxcollider.size.x, boxcollider.size.y,
                                                     -boxcollider.size.z)*0.5f);
        vertices[7] =
            boxcollider.transform.TransformPoint(boxcollider.center +
                                                 new Vector3(boxcollider.size.x, boxcollider.size.y, -boxcollider.size.z)*
                                                 0.5f);

        return vertices;
    }
}
</code></pre>

              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://bouvet1.github.io/post/unity54-she-xiang-ji-wei-rao-wu-ti-xuan-zhuan-yu-fang-xiang-cao-zuo">
              <h3 class="post-title">
                Unity5.4 摄像机围绕物体旋转与方向操作
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  
  <a class="rss" href="https://bouvet1.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
