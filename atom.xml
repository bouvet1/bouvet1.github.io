<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://bouvet1.github.io</id>
    <title>Bouvet</title>
    <updated>2020-01-02T08:41:44.632Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://bouvet1.github.io"/>
    <link rel="self" href="https://bouvet1.github.io/atom.xml"/>
    <subtitle>Cyberpunk!</subtitle>
    <logo>https://bouvet1.github.io/images/avatar.png</logo>
    <icon>https://bouvet1.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Bouvet</rights>
    <entry>
        <title type="html"><![CDATA[Unity编辑器界面中添加包二维码]]></title>
        <id>https://bouvet1.github.io/post/unity-bian-ji-qi-jie-mian-zhong-tian-jia-bao-er-wei-ma</id>
        <link href="https://bouvet1.github.io/post/unity-bian-ji-qi-jie-mian-zhong-tian-jia-bao-er-wei-ma">
        </link>
        <updated>2020-01-02T06:53:11.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<h2 id="痛点">🔔<strong>痛点</strong></h2>
每一次的游戏在Jenkins打包后，都需要在通过二维码生成网站将打包好后的下载链接转换成二维码让手机扫码下载，太过于繁琐。</li>
<li>
<h2 id="需求">💬<strong>需求</strong></h2>
能够在unity界面下直接显示最新的二维码界面，打包完成后直接通过手机扫码即可，方便很多。</li>
<li>
<h2 id="实现">💭<strong>实现</strong></h2>
1 爬虫爬取Jenkins站内包信息<br>
2 每一次刷新unity获取Jenkins最新信息，刷新二维码<br>
3 取得下载链接，转成二维码显示到unity编辑器</li>
<li>
<h2 id="效果">🎊<strong>效果</strong></h2>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://bouvet1.github.io/post-images/1577949499798.png" alt="" loading="lazy"></figure>
<ul>
<li>
<h2 id="代码">💻<strong>代码</strong></h2>
<h3 id="生成qr"><strong>生成QR</strong></h3>
<p>通过zxing库生成QR Texture2D</p>
<pre><code>public Texture2D generateQR(string qr)
{
    Texture2D encoded = new Texture2D(200, 200, TextureFormat.RGBA32, false);
    var colors = Encode(qr, 200, 200);
    encoded.SetPixels32(colors);
    encoded.Apply();
    return encoded;
}

private static Color32[] Encode(string textForEncoding, int width, int height) 
{
    var writer = new BarcodeWriter
    {
        Format = BarcodeFormat.QR_CODE,
        Options = new QrCodeEncodingOptions
        {
            Height = height,
            Width = width,
            Margin = 2,
            PureBarcode = true
        }
    };
    return writer.Write(textForEncoding);
}
</code></pre>
<h3 id="显示到unity编辑器"><strong>显示到Unity编辑器</strong></h3>
<pre><code>QRtex = QRManager.Instance.generateQR(apkUrl); //获取QR
GUILayout.Box(QRtex, GUILayout.ExpandWidth(true));//显示QR
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity对象池封装]]></title>
        <id>https://bouvet1.github.io/post/unity-dui-xiang-chi-feng-zhuang</id>
        <link href="https://bouvet1.github.io/post/unity-dui-xiang-chi-feng-zhuang">
        </link>
        <updated>2018-04-24T06:18:36.000Z</updated>
        <content type="html"><![CDATA[<p>一共分为两个类，SubPool与ObjectPool，SubPool类为总对象池包含ObjectPool的子池子，ObjectPool包含需要入池的对象。</p>
<p>调用方法：</p>
<ul>
<li>入池：ObjectPool.Instance.Spawn()</li>
<li>出池：ObjectPool.Instance.UnSpawn()</li>
<li>全部出池：ObjectPool.Instance.UnSpawnAll()</li>
<li>销毁池子：ObjectPool.Instance.DisPool();</li>
</ul>
<p>SubPool类(继承至单例父类)</p>
<pre><code>using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class SubPool
{
    List&lt;GameObject&gt; Pool=new List&lt;GameObject&gt;();

    /// &lt;summary&gt;
    /// 入池
    /// &lt;/summary&gt;
    public GameObject Spawn(string obj)
    {
            foreach (GameObject item in Pool)
            {
                if (!item.activeSelf)
                {
                    item.SetActive(true);
                    item.SendMessage(&quot;Spawn&quot;,SendMessageOptions.DontRequireReceiver);
                    return item;
                }
            }
        GameObject go = CreateObj(obj);
        Pool.Add(go);
       go.SendMessage(&quot;Spawn&quot;,SendMessageOptions.DontRequireReceiver);
        return go;
    }

/// &lt;summary&gt;
/// 出池
/// &lt;/summary&gt;
/// &lt;param name=&quot;go&quot;&gt;&lt;/param&gt;
 public void UnSpawn(GameObject go=null,string goname=&quot;&quot;)
    {
        if (go!=null)
        {
            go.SetActive(false);
        }
        else
        {
            for (int i = 0; i &lt; Pool.Count; i++)
            {
                if (Pool[i].activeSelf)
                {
                    Pool[i].SetActive(false);
                    return;
                }
            }
        }
    }

/// &lt;summary&gt;
/// 全部出池
/// &lt;/summary&gt;
public void UnSpawnAll()
    {
        foreach (GameObject item in Pool)
        {
            item.SetActive(false);
        }
    }

    /// &lt;summary&gt;
    /// 创建对象
    /// &lt;/summary&gt;
    GameObject CreateObj(string obj)
    {
        GameObject go = GameObject.Instantiate(Resources.Load(&quot;Prefabs/Others/&quot;+obj) as GameObject);
        go.transform.SetParent(GameObject.Find(&quot;Pool&quot;).transform, false);
        go.name = go.name.Replace(&quot;(Clone)&quot;, &quot;&quot;);
        return go;
    }
}

</code></pre>
<p>ObjectPool类</p>
<pre><code>using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using Framework;

public class ObjectPool:Manager&lt;ObjectPool&gt;
{
    ObjectPool()
    {
    }

    Dictionary&lt;string,SubPool&gt; pools= new Dictionary&lt;string, SubPool&gt;();
    
    /// &lt;summary&gt;
    /// 入池
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;obj&quot;&gt;创建的对象名&lt;/param&gt;
    public GameObject Spawn(string obj)
    {
            if (pools.ContainsKey(obj))
            {
                return pools[obj].Spawn(obj);
            }
            else
            {
                SubPool sp = new SubPool();
               var go = sp.Spawn(obj);
                pools.Add(obj, sp);
                return go;
            }
        return null;
    }

    /// &lt;summary&gt;
    /// 出池
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;go&quot;&gt;需要出池对象&lt;/param&gt;
    public void UnSpawn(GameObject go=null,string goName=&quot;&quot;)
    {
        if (!go)
        {
            if (pools.ContainsKey(goName))
            {
                pools[goName].UnSpawn(null,goName);
            }
        }
        else
        {
            if (pools.ContainsKey(go.name))
            {
                pools[go.name].UnSpawn(go);
            }
        }

    }

    /// &lt;summary&gt;
    /// 全部出池
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;pool&quot;&gt;出池的名称&lt;/param&gt;
    public void UnSpawnAll(string pool)
    {
        if (pools.ContainsKey(pool))
        {
            pools[pool].UnSpawnAll();
        }
    }

    /// &lt;summary&gt;
    /// 销毁池子
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;pool&quot;&gt;销毁池的名称&lt;/param&gt;
    public void DisPool(string pool)
    {
        if (pools.ContainsKey(pool))
        {
            pools.Remove(pool);
        }
    }


}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity5.4 UGUI制作实时数据线性图表]]></title>
        <id>https://bouvet1.github.io/post/unity54-ugui-zhi-zuo-shi-shi-shu-ju-xian-xing-tu-biao</id>
        <link href="https://bouvet1.github.io/post/unity54-ugui-zhi-zuo-shi-shi-shu-ju-xian-xing-tu-biao">
        </link>
        <updated>2017-12-13T06:18:22.000Z</updated>
        <content type="html"><![CDATA[<p>效果预览：<br>
<img src="http://upload-images.jianshu.io/upload_images/101711-9badfc5da37b04de.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.gif" loading="lazy"></p>
<p>使用方法：</p>
<pre><code>//开始执行:浮动值，浮动值范围，X轴属性，Y轴属性,浮动线粗细
DataSheet.DataSheet1.Setup(Value,100,X,Y,5);
</code></pre>
<p>源代码</p>
<pre><code>using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using DG.Tweening;
using UnityEngine.UI;

public class DataSheet
{
    private static DataSheet dataSheet;

    public static DataSheet DataSheet1
    {
        get
        {
            if (dataSheet==null)
            {
                dataSheet=new DataSheet();
            }
            return dataSheet;
        }
    }

    private Canvas canvas;
    public int Quantity = 5;
    private GameObject Line;
    private GameObject DataPoint;
    private RectTransform DataPointRectTramsform;
    public  float LineThickness;
    DataSheet()
    {
        canvas = GameObject.Find(&quot;Canvas&quot;).GetComponent&lt;Canvas&gt;();
        Line = GameObject.Find(&quot;Line&quot;);
        DataPoint = GameObject.Find(&quot;DataPoint&quot;);
        DataPointRectTramsform = DataPoint.GetComponent&lt;RectTransform&gt;();
    }

    private float[] Values;
    private List&lt;GameObject&gt; DataPoints;
    private List&lt;GameObject&gt; Lines;
    private List&lt;GameObject&gt; YLines=new List&lt;GameObject&gt;();
    private float k;
    private int ValueCount;
    /// &lt;summary&gt;
    /// 开始执行:浮动值，浮动值范围，X轴属性，Y轴属性,浮动线粗细
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;Value&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;hight&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;XNames&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;YName&quot;&gt;&lt;/param&gt;
    public void Setup(float Value,float hight,string[] XNames,string[] YNames,float LineThickness)
    {
        //生成数据点与线条
        if (DataPoints == null)
        {
            this.LineThickness = LineThickness;
            ValueCount =XNames.Length;
            //生成数据点
            Lines=new List&lt;GameObject&gt;();
            DataPoints = new List&lt;GameObject&gt;();
            var GoX = DataPointRectTramsform.rect.width / ValueCount;
            var GoXStart = 0-(DataPointRectTramsform.rect.width / 2);
            for (int i = 0; i &lt; ValueCount; i++)
            {
                GameObject Go = GameObject.Instantiate(Resources.Load&lt;GameObject&gt;(&quot;Prefabs/DataPoint&quot;));
                Go.transform.SetParent(DataPoint.transform, false);
                DataPoints.Add(Go);
                Go.GetComponent&lt;RectTransform&gt;().localPosition = new Vector3(GoXStart+(GoX*(i+1)-GoX/2),-DataPointRectTramsform.rect.height/2);

                //生成X轴属性名
                GameObject Xname = GameObject.Instantiate(Resources.Load&lt;GameObject&gt;(&quot;Prefabs/NameText&quot;));
                Xname.transform.SetParent(DataPoint.transform.parent.GetChild(2), false);
                Xname.GetComponent&lt;Text&gt;().text = XNames[i];

                if (i == ValueCount-1) { break; }
                //生成连接线条
                GameObject line = GameObject.Instantiate(Resources.Load&lt;GameObject&gt;(&quot;Prefabs/LineChild&quot;));
                line.transform.SetParent(Line.transform,false);
                Lines.Add(line);
            }
            for (int i = 0; i &lt;YNames.Length ; i++)
            {
                //生成Y轴属性名
                GameObject Yname = GameObject.Instantiate(Resources.Load&lt;GameObject&gt;(&quot;Prefabs/NameText&quot;));
                Yname.transform.SetParent(DataPoint.transform.parent.GetChild(0), false);
                Yname.GetComponent&lt;Text&gt;().text = YNames[i];
                YLines.Add(Yname);
                //生成Y轴线
                GameObject YnameLine = GameObject.Instantiate(Resources.Load&lt;GameObject&gt;(&quot;Prefabs/YNameLineImage&quot;));
                YnameLine.transform.SetParent(DataPoint.transform.parent.GetChild(1), false);
                var Y = Yname.GetComponent&lt;RectTransform&gt;().position;
                YnameLine.GetComponent&lt;RectTransform&gt;().localPosition=new Vector3(0,0,0);
            }
            
        }
        DataFloat(Value,ValueCount,hight);
        LineFloat();
       
    }

    //设置数据点浮动
    void DataFloat(float Value, int ValueCount, float hight)
    {
        if (Values == null)
        {
            Values = new float[ValueCount];
            for (int i = 0; i &lt; Values.Length; i++)
            {
                Values[i] = -DataPointRectTramsform.rect.height / 2;
            }
        }
        float percent = (Convert.ToSingle(Value) / Convert.ToSingle(hight) * DataPointRectTramsform.rect.height) + (-DataPointRectTramsform.rect.height / 2);

        if (Values[0] != k)
        {
            for (int i = Values.Length - 1; i &lt; Values.Length; i--)
            {

                Values[i] = Values[i - 1];
                if (i == 1)
                {
                    Values[0] = percent;
                    break;
                }
            }

            for (int i = 0; i &lt; Values.Length; i++)
            {
                DataPoints[i].GetComponent&lt;RectTransform&gt;().DOLocalMoveY(Values[i], 0.5f);
            }
        }
        k = percent;
    }

    //设置线条浮动
    void LineFloat()
    {
        for (int i = 0; i &lt; ValueCount - 1; i++)
        {
            Vector2 pos;
            if (RectTransformUtility.ScreenPointToLocalPointInRectangle(canvas.transform as RectTransform,
                DataPoints[i].transform.position, canvas.worldCamera, out pos))
            {
            }


            Vector2 pos1;
            if (RectTransformUtility.ScreenPointToLocalPointInRectangle(canvas.transform as RectTransform,
                DataPoints[i + 1].transform.position, canvas.worldCamera, out pos1))
            {
            }

            var height = pos.y - pos1.y;
            var widht = pos.x - pos1.x;
            Lines[i].GetComponent&lt;RectTransform&gt;().sizeDelta = new Vector2(widht, height);
            var x = (pos.x + pos1.x) / 2;
            var y = (pos.y + pos1.y) / 2;
            Lines[i].GetComponent&lt;RectTransform&gt;().localPosition = new Vector3(x, y);
        }
    }
}

</code></pre>
<p>项目地址<br>
https://github.com/baishuisr1/-DataSheet</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity5.4 利用函数设置副物体跟随主物体旋转]]></title>
        <id>https://bouvet1.github.io/post/unity54-li-yong-han-shu-she-zhi-fu-wu-ti-gen-sui-zhu-wu-ti-xuan-zhuan</id>
        <link href="https://bouvet1.github.io/post/unity54-li-yong-han-shu-she-zhi-fu-wu-ti-gen-sui-zhu-wu-ti-xuan-zhuan">
        </link>
        <updated>2017-12-13T06:18:12.000Z</updated>
        <content type="html"><![CDATA[<p>效果(用鼠标控制副物体旋转)：<br>
<img src="http://upload-images.jianshu.io/upload_images/101711-d568ccdf589f0617.gif?imageMogr2/auto-orient/strip" alt="image" loading="lazy"></p>
<p>通公式获取圆的下一个坐标位置：<br>
x = vector3.x + r * cos(angle * PI / 180)<br>
z = Vector3.z + r * sin(angle * PI /180)<br>
源代码:</p>
<pre><code>public class Test : MonoBehaviour
{
    private Transform CylinderTranform;
    private float r;
    // Use this for initialization
    void Start()
    {
        CylinderTranform = GameObject.Find(&quot;Cylinder&quot;).transform;//获取主物体坐标
         r = Vector3.Distance(transform.position, CylinderTranform.position);//获取主物体与跟随物体距离，即半径
    }

    float MouseX;
    // Update is called once per frame
    void Update()
    {
        transform.LookAt(CylinderTranform);
        MouseX += Input.GetAxis(&quot;Mouse X&quot;)*5;//获取鼠标位置*5
        //主物体X+半径*cos(鼠标位置*pi/180)
        var x = CylinderTranform.position.x + r*Mathf.Cos(-MouseX*Mathf.PI/180);
        var z = CylinderTranform.position.z + r*Mathf.Sin(-MouseX*Mathf.PI/180);
        transform.position = new Vector3(x, CylinderTranform.position.y, z);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity5.4 保存日志记录TXT文件到本地]]></title>
        <id>https://bouvet1.github.io/post/unity54-bao-cun-ri-zhi-ji-lu-txt-wen-jian-dao-ben-di</id>
        <link href="https://bouvet1.github.io/post/unity54-bao-cun-ri-zhi-ji-lu-txt-wen-jian-dao-ben-di">
        </link>
        <updated>2017-11-08T06:18:03.000Z</updated>
        <content type="html"><![CDATA[<p>GitHub：https://github.com/baishuisr1/Unity-Save-the-log</p>
<p>使用方法：<br>
将Write.cs挂载到GameObject<br>
在Awake或start中调用Write.console.LogStart();<br>
输出方法：Write.Log()<br>
<img src="http://upload-images.jianshu.io/upload_images/101711-c6943ad4f824f2e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="截图.png" loading="lazy"><br>
输出TXT，默认地址为/StreamingAssets/Log文件夹下（注：文件保存只会在打包后输出，IDE中运行不会保存文件）<br>
Weite.Log()输出格式:时间-调用类-调用方法-输出内容<br>
默认输出格式：时间-信息类型-相关代码所在地址-内容<br>
<img src="http://upload-images.jianshu.io/upload_images/101711-9f815260905d9f18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="截图.png" loading="lazy"></p>
<p>源代码：</p>
<pre><code>using System;
using System.Diagnostics;
using System.IO;
using System.Text;
using UnityEngine;
using Debug = UnityEngine.Debug;

public class Write : MonoBehaviour
{
    private static FileStream FileWriter;
    private static UTF8Encoding encoding;
    private static Write _consoleLog;
    private static bool _AllDisplay;
    private static bool _LogDisplay;
    private static bool _WarningDisplay;
    private static bool _LogData;
    private static bool IsIDE;
    private FileInfo fileInfo;
    private string NowTime;

    public static Write console //开启单例
    {
        get
        {
            if (_consoleLog == null)
                _consoleLog = new Write();
            return _consoleLog;
        }
    }

    /// &lt;summary&gt;
    ///     开始写入日志，参数一：是否写入Warning类型数据，默认不写入，参数二：是否写入Debug.Log类型数据，默认不写入，参数三：是否写入全部数据，默认不写入,参数四：是否将Log方法信息输出到控制台，默认输出
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;WarningDisplay&quot;&gt;&lt;/param&gt;
    public void LogStart(bool WarningDisplay = false, bool LogDisplay = false, bool AllDisplay = false,
        bool LogData = true)
    {

        if ((FileWriter == null))
        {
            IsIDE = Application.isEditor; //获取当前场景运行环境
            _WarningDisplay = WarningDisplay;
            _LogDisplay = LogDisplay;
            _AllDisplay = AllDisplay;
            _LogData = LogData;
            if (IsIDE == false) //判断当前场景运行环境，如果是Editor中则不执行
            {
                Directory.CreateDirectory(Application.dataPath + &quot;/StreamingAssets&quot;);
                Directory.CreateDirectory(Application.dataPath + &quot;/StreamingAssets/&quot; + &quot;Log&quot;);
                NowTime = DateTime.Now.ToString().Replace(&quot; &quot;, &quot;_&quot;).Replace(&quot;/&quot;, &quot;_&quot;).Replace(&quot;:&quot;, &quot;_&quot;);
                fileInfo = new FileInfo(Application.dataPath + &quot;/StreamingAssets/Log/&quot; + NowTime + &quot;_Log.txt&quot;);
                //设置Log文件输出地址
                FileWriter = fileInfo.Open(FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.Read);
                encoding = new UTF8Encoding();
                Application.logMessageReceived += LogCallback;
            }
        }
    }

    /// &lt;summary&gt;
    ///     替代Debug.log写入Log信息
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;_log&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;con&quot;&gt;&lt;/param&gt;
    public static void Log(object _log)
    {
        if ((_LogDisplay == false) &amp;&amp; (_AllDisplay == false))
        {
            if (_LogData)
                Debug.Log(_log);
            if (IsIDE == false)
            {
                try
                {
                    var trace = new StackTrace(); //获取调用类信息
                    var ClassName = trace.GetFrame(1).GetMethod().DeclaringType.Name;
                    var WayName = trace.GetFrame(1).GetMethod().Name;
                    var log = DateTime.Now + &quot; &quot; + &quot;[&quot; + ClassName + &quot;.&quot; + WayName + &quot;]&quot; + &quot; &quot; + &quot;:&quot; + &quot; &quot; + _log +
                              Environment.NewLine;
                    FileWriter.Write(encoding.GetBytes(log), 0, encoding.GetByteCount(log));
                }
                catch (Exception)
                {
                    Debug.Log(&quot;请检测是否调用了Console.LogStart方法,或者关闭控制台Log写入与所有数据写入项&quot;);
                }

            }
        }
        else
        {
            Debug.Log(&quot;请检测是否调用了Console.LogStart方法,或者关闭控制台Log写入与所有数据写入项&quot;);
        }
    }

    private void LogCallback(string condition, string stackTrace, LogType type) //写入控制台数据
    {
        string content = null;
        if (_AllDisplay == false)
        {
            if (type.ToString() == &quot;Warning&quot;)
                if (_WarningDisplay == false)
                {
                    condition = &quot;&quot;;
                    stackTrace = &quot;&quot;;
                    content = &quot;&quot;;
                }
                else
                {
                    content = DateTime.Now + &quot; &quot; + &quot;[&quot; + type + &quot;]&quot; + &quot;[&quot; + stackTrace + &quot;]&quot; + &quot; &quot; + &quot;:&quot; + &quot; &quot; +
                              condition +
                              Environment.NewLine;
                }

            if (type.ToString() == &quot;Log&quot;)
                if (_LogDisplay == false)
                {
                    condition = &quot;&quot;;
                    stackTrace = &quot;&quot;;
                    content = &quot;&quot;;
                }
                else
                {
                    content = DateTime.Now + &quot; &quot; + &quot;[&quot; + type + &quot;]&quot; + &quot;[&quot; + stackTrace + &quot;]&quot; + &quot; &quot; + &quot;:&quot; + &quot; &quot; +
                              condition +
                              Environment.NewLine;
                }
            if (type.ToString() == &quot;Exception&quot;)
                content = DateTime.Now + &quot; &quot; + &quot;[&quot; + type + &quot;]&quot; + &quot;[&quot; + stackTrace + &quot;]&quot; + &quot; &quot; + &quot;:&quot; + &quot; &quot; + condition +
                          Environment.NewLine;
        }
        else
        {
            content = DateTime.Now + &quot; &quot; + &quot;[&quot; + type + &quot;]&quot; + &quot;[&quot; + stackTrace + &quot;]&quot; + &quot; &quot; + &quot;:&quot; + &quot; &quot; + condition +
                      Environment.NewLine;
        }
        FileWriter.Write(encoding.GetBytes(content), 0, encoding.GetByteCount(content));
        FileWriter.Flush();
    }

    private void OnDestroy() //关闭写入
    {
        if ((FileWriter != null) &amp;&amp; (IsIDE == false))
        {
            FileWriter.Close();
            Application.RegisterLogCallback(null);
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity5.4 通过PHP连接数据库与Socket服务器]]></title>
        <id>https://bouvet1.github.io/post/unity54-tong-guo-php-lian-jie-shu-ju-ku-yu-socket-fu-wu-qi</id>
        <link href="https://bouvet1.github.io/post/unity54-tong-guo-php-lian-jie-shu-ju-ku-yu-socket-fu-wu-qi">
        </link>
        <updated>2017-10-20T06:17:45.000Z</updated>
        <content type="html"><![CDATA[<p>公司给一个项目要求程序发布WebGL端同时连接pgSQL与Socket服务器，因为Unity WebGL是无法连接数据库与Socket通讯的，所以就通过PHP作为中间转接层来获取数据，代码如下：</p>
<p>注：PHP需要搭建环境，推荐Wampserver。</p>
<p>GitHub:https://github.com/baishuisr1/-Unity-Connect-the-pgSQL-with-the-Socket-server-via-PHP</p>
<p>演示(由于PHP不支持多线程，所以是间隔时间来获取数据)：<br>
<img src="http://upload-images.jianshu.io/upload_images/101711-2e46b7591304fadb.gif?imageMogr2/auto-orient/strip" alt="Unity PHP连接服务器.gif" loading="lazy"><br>
数据库截图：<br>
<img src="http://upload-images.jianshu.io/upload_images/101711-54709ecce5af4c67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="%E6%88%AA%E5%.png" loading="lazy"><br>
服务器代码：</p>
<pre><code>using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Xml;


namespace ConsoleApp5
{
    class Program
    {
        static void Main(string[] args)
        {
            Program program = new Program();
            program.StartServer();
            Console.ReadKey();
        }

        void StartServer() //服务器异步连接
        {
            Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            IPAddress ipAddress = IPAddress.Parse(&quot;x.x.x.x&quot;); //设置IP
            IPEndPoint ipEndPoint = new IPEndPoint(ipAddress,xxxx); //设置IP和端口号
            socket.Bind(ipEndPoint); //绑定IP和端口号
            socket.Listen(0); //开始监听客户端
            socket.BeginAccept(AcceptCallBack, socket); //通过BeginAccept进行异步连接
            Console.ReadKey();
        }

        void AcceptCallBack(IAsyncResult ar)
        {
            Console.WriteLine(&quot;有一个客户端连接了&quot;);
            Socket socket = ar.AsyncState as Socket;
            Socket clientSocket = socket.EndAccept(ar);
            //向客户端发送一条消息
            string date = &quot;服务器连接成功&quot;;
            byte[] msg = System.Text.Encoding.UTF8.GetBytes(date);
            clientSocket.Send(msg);
            clientSocket.BeginReceive(dateBuffer, 0, 1024, SocketFlags.None, ReceiveCallBcak, clientSocket);
            socket.BeginAccept(AcceptCallBack, socket);
        }

        static byte[] dateBuffer = new byte[1024];
        private int i=1;
        void ReceiveCallBcak(IAsyncResult ar) //事件，ar传递值
        {
            Socket clientSocket = null;
            try
            {
                clientSocket = ar.AsyncState as Socket;
                int count = clientSocket.EndReceive(ar);
                string msg = Encoding.UTF8.GetString(dateBuffer, 0, count);//获取客户端发来数据
                Console.WriteLine(&quot;客户端发送消息：&quot; + msg);
                i++;
                Thread.Sleep(2000);//等待2秒再次发送数据
                byte[] date = Encoding.UTF8.GetBytes(i.ToString());
                clientSocket.Send(date);//发送数据
                Console.WriteLine(&quot;服务器发送数据：&quot; + Encoding.UTF8.GetString(date));
                clientSocket.BeginReceive(dateBuffer, 0, 1024, SocketFlags.None, ReceiveCallBcak, clientSocket);
            }
            catch (Exception)
            {
                Console.WriteLine(&quot;客户端断开连接&quot;);
            }
        }
    }
}
</code></pre>
<p>PHP代码：</p>
<pre><code>&lt;?php
//连接数据库
$conn = pg_connect(&quot;host=127.0.0.1 port=5432 dbname=xxxxx user=postgres password=xxxxx&quot;);
$str = &quot;select * from \&quot;Test\&quot;&quot;;
$ret = pg_query($conn,$str);
while($row = pg_fetch_row($ret)){
    echo $row[0];//输出数据库ID[1]
    echo $row[1];//输出数据库ID[2]
}
//连接SOCKET
$host = &quot;x.x.x.x&quot;;
$port= &quot;xxxx&quot;;
$socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);
$result=socket_connect($socket,$host,$port);
    $budder=@socket_read($socket,1024);//接受Scket数据
    echo $budder;
    $userid=$_POST['msg'];//获取unity发来数据
    socket_write($socket,$userid); //将unity数据发送到socket
    $budder=@socket_read($socket,1024);//重新接受unity数据
    echo $budder;
socket_close($socket);
?&gt;  
</code></pre>
<p>Unity 代码:</p>
<pre><code>using UnityEngine;
using System.Collections;
using UnityEngine.UI;

public class NewBehaviourScript : MonoBehaviour
{
    public GameObject text;
    // Use this for initialization
    void Start()
    {
        StartCoroutine(IGetData());
    }

    // Update is called once per frame
    void Update()
    {

    }

    IEnumerator IGetData()
    {
        while (true)
        {
            WWWForm form = new WWWForm();
            form.AddField(&quot;msg&quot;, &quot;Server&quot;);//设置发送数据
            WWW www = new WWW(&quot;http://127.0.0.1/index.php&quot;, form);//下载与上传数据
            yield return www; //等待Web服务器
            text.GetComponent&lt;Text&gt;().text = www.text;
            Debug.Log(www.text);
        }

    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[unity5.4 通过计时器方法实现执行时间间隔与延时执行]]></title>
        <id>https://bouvet1.github.io/post/unity54-tong-guo-ji-shi-qi-fang-fa-shi-xian-zhi-xing-shi-jian-jian-ge-yu-yan-shi-zhi-xing</id>
        <link href="https://bouvet1.github.io/post/unity54-tong-guo-ji-shi-qi-fang-fa-shi-xian-zhi-xing-shi-jian-jian-ge-yu-yan-shi-zhi-xing">
        </link>
        <updated>2017-09-19T06:17:26.000Z</updated>
        <content type="html"><![CDATA[<p>协程方法实现必须继承MonoBehaviour类，如果写的类不继承MonoBehaviour就无法使用，只能通过计时器来写。不过也有个好处，写成timer类所有需要延迟执行的方法都可以调用。</p>
<p>代码如下：</p>
<pre><code>using UnityEngine;

public class Test : MonoBehaviour
{
    private bool choose = true;
    private float timer;
    public void Timer()
    {
        if (choose == false)
        {
            timer += Time.deltaTime;//开始计时
            if (timer &gt; 2)//延迟2S执行
            {
                choose = true;
                timer = 0;
            }
        }
    }
    void Update ()
    {   
        Timer();
        if (Input.GetKeyDown(KeyCode.Mouse0)&amp;&amp;choose==true)
        {
            choose = false;
            Debug.Log(&quot;run&quot;);
        }
    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Uniy5.4 实现动态3D图表效果 一]]></title>
        <id>https://bouvet1.github.io/post/uniy54-shi-xian-dong-tai-3d-tu-biao-xiao-guo-yi</id>
        <link href="https://bouvet1.github.io/post/uniy54-shi-xian-dong-tai-3d-tu-biao-xiao-guo-yi">
        </link>
        <updated>2017-08-18T06:19:00.000Z</updated>
        <content type="html"><![CDATA[<p>原本想使用插件来做，奈何囊中羞涩，只能自己写了。通过Value值修改高度。效果图：<br>
<img src="http://upload-images.jianshu.io/upload_images/101711-55674da7f3c5586a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" loading="lazy"><br>
代码：</p>
<pre><code>using UnityEngine;
using System.Collections;
using UnityEngine;
using System.Collections;

public class cube : MonoBehaviour
{
    private Vector3[] vertices;
    private Mesh mesh;
    [Range(0, 10)]
    public float value = 1;//设置高度值
    // Use this for initialization
    void Start()
    {
        vertices = GetComponent&lt;MeshFilter&gt;().mesh.vertices;//获取Gameobject meshfilter组件
        mesh = GetComponent&lt;MeshFilter&gt;().mesh;//获取meshfilter组件中mesh数组数据
    }

    // Update is called once per frame
    void Update()
    {
        for (int i = 0; i &lt; vertices.Length; i++)//遍历数组
        {

            if (vertices[i].y &gt;= 0f)//判断mesh是否为顶部
            {
                vertices[i].y = value;//设置mesh顶部高度等于高度值
            }
        }
        mesh.vertices = vertices;//刷新
    }
}
</code></pre>
<p>项目地址：https://github.com/baishuisr1/Unity-3D-Chart</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity 5.4 为模型组一键添加碰撞体(Collider)插件]]></title>
        <id>https://bouvet1.github.io/post/unity-54-wei-mo-xing-zu-yi-jian-tian-jia-peng-zhuang-ti-collidercha-jian</id>
        <link href="https://bouvet1.github.io/post/unity-54-wei-mo-xing-zu-yi-jian-tian-jia-peng-zhuang-ti-collidercha-jian">
        </link>
        <updated>2017-08-18T06:17:04.000Z</updated>
        <content type="html"><![CDATA[<p>效果图：<br>
<img src="http://upload-images.jianshu.io/upload_images/101711-16430da342436f83.gif?imageMogr2/auto-orient/strip" alt="" loading="lazy"></p>
<p>插件下载地址：<br>
https://github.com/baishuisr1/Unity-Add-Game-group-Collider-Plugin</p>
<p>源码:</p>
<pre><code>using System;
using UnityEngine;
using UnityEditor;

public class AddCollider : EditorWindow
{
    [MenuItem(&quot;Window/辅助功能&quot;)]
    static void Window()
    {
        AddCollider newWindow = EditorWindow.GetWindow&lt;AddCollider&gt;(&quot;辅助功能&quot;);
        newWindow.Show();
    }


    private string zoom = &quot;100&quot;;

    void OnGUI()
    {
        GUILayout.Label(&quot;碰撞器缩放_百分比(默认100%)&quot;);
        zoom = GUILayout.TextField(zoom);
        if (GUILayout.Button(&quot;添加碰撞体积&quot;))
        {
            float zoomFloat = Convert.ToSingle(zoom)/100;
            if (zoomFloat &gt; 1.5)
            {
                Debug.Log(&quot;请输入1-150的数&quot;);
                return;
            }
            if (zoomFloat &lt; 0.1)
            {
                Debug.Log(&quot;请输入1-150的数&quot;);
                return;
            }
            GameObject gameObject = Selection.activeGameObject;
            if (gameObject == null)
            {
                Debug.Log(&quot;请选择一个物体&quot;);
                return;
            }

            Vector3 vector3;
            vector3 = gameObject.transform.position;
            gameObject.transform.position =new Vector3(0,0,0);

            float Y_Max = -5000;
            float Y_Mix = 5000;

            float X_Max = -5000;
            float X_Mix = 5000;

            float Z_Max = -5000;
            float Z_Mix = 5000;

            foreach (Transform VARIABLE in gameObject.transform)
            {
                BoxCollider boxCollider = VARIABLE.transform.gameObject.AddComponent&lt;BoxCollider&gt;();
                Vector3[] vector3s = GetBoxColliderVertexPositions(boxCollider);
                for (int i = 0; i &lt; vector3s.Length; i++)
                {
                    if (vector3s[i].y &gt;= Y_Max)
                    {
                        Y_Max = vector3s[i].y;
                    }

                    if (vector3s[i].y &lt;= Y_Mix)
                    {
                        Y_Mix = vector3s[i].y;
                    }

                    if (vector3s[i].x &gt;= X_Max)
                    {
                        X_Max = vector3s[i].x;
                    }

                    if (vector3s[i].x &lt;= X_Mix)
                    {
                        X_Mix = vector3s[i].x;
                    }

                    if (vector3s[i].z &gt;= Z_Max)
                    {
                        Z_Max = vector3s[i].z;
                    }

                    if (vector3s[i].z &lt;= Z_Mix)
                    {
                        Z_Mix = vector3s[i].z;
                    }
                }
            }


            Y_Max *= zoomFloat;
            Y_Mix *= zoomFloat;

            X_Max *= zoomFloat;
            X_Mix *= zoomFloat;

            Z_Max *= zoomFloat;
            Z_Mix *= zoomFloat;


            gameObject.AddComponent&lt;MeshCollider&gt;();
            Mesh mesh = new Mesh();
            mesh.name = gameObject.name;
            int[] triangles = new int[36];
            Vector3[] vertices = new Vector3[24];

            Vector3 verticeUp1 = new Vector3(X_Mix, Y_Max, Z_Max);
            vertices[3] = verticeUp1;
            vertices[9] = verticeUp1;
            vertices[21] = verticeUp1;
            Vector3 verticeUp2 = new Vector3(X_Mix, Y_Max, Z_Mix);
            vertices[5] = verticeUp2;
            vertices[11] = verticeUp2;
            vertices[20] = verticeUp2;
            Vector3 verticeUp3 = new Vector3(X_Max, Y_Max, Z_Mix);
            vertices[4] = verticeUp3;
            vertices[10] = verticeUp3;
            vertices[18] = verticeUp3;
            Vector3 verticeUp4 = new Vector3(X_Max, Y_Max, Z_Max);
            vertices[2] = verticeUp4;
            vertices[8] = verticeUp4;
            vertices[19] = verticeUp4;

            Vector3 verticeDown1 = new Vector3(X_Max, Y_Mix, Z_Max);
            vertices[0] = verticeDown1;
            vertices[14] = verticeDown1;
            vertices[17] = verticeDown1;
            Vector3 verticeDown2 = new Vector3(X_Mix, Y_Mix, Z_Max);
            vertices[1] = verticeDown2;
            vertices[15] = verticeDown2;
            vertices[23] = verticeDown2;
            Vector3 verticeDown3 = new Vector3(X_Mix, Y_Mix, Z_Mix);
            vertices[7] = verticeDown3;
            vertices[13] = verticeDown3;
            vertices[22] = verticeDown3;
            Vector3 verticeDown4 = new Vector3(X_Max, Y_Mix, Z_Mix);
            vertices[6] = verticeDown4;
            vertices[12] = verticeDown4;
            vertices[16] = verticeDown4;

            int currentCount = 0;
            for (int i = 0; i &lt; 24; i = i + 4)
            {
                //三角形1
                triangles[currentCount++] = i;
                triangles[currentCount++] = i + 3;
                triangles[currentCount++] = i + 1;
                //三角形2        
                triangles[currentCount++] = i;
                triangles[currentCount++] = i + 2;
                triangles[currentCount++] = i + 3;
            }

            mesh.vertices = vertices;
            mesh.triangles = triangles;
            gameObject.GetComponent&lt;MeshCollider&gt;().sharedMesh = mesh;

            foreach (Transform VARIABLE in gameObject.transform)
            {
                DestroyImmediate(VARIABLE.GetComponent&lt;BoxCollider&gt;());
            }
            gameObject.transform.position = vector3;
        }
    }

    Vector3[] GetBoxColliderVertexPositions(BoxCollider boxcollider)
    {
        var vertices = new Vector3[8];
        
        vertices[0] =
            boxcollider.transform.TransformPoint(boxcollider.center +
                                                 new Vector3(boxcollider.size.x, -boxcollider.size.y, boxcollider.size.z)*
                                                 0.5f);
        vertices[1] =
            boxcollider.transform.TransformPoint(boxcollider.center +
                                                 new Vector3(-boxcollider.size.x, -boxcollider.size.y,
                                                     boxcollider.size.z)*0.5f);
        vertices[2] =
            boxcollider.transform.TransformPoint(boxcollider.center +
                                                 new Vector3(-boxcollider.size.x, -boxcollider.size.y,
                                                     -boxcollider.size.z)*0.5f);
        vertices[3] =
            boxcollider.transform.TransformPoint(boxcollider.center +
                                                 new Vector3(boxcollider.size.x, -boxcollider.size.y,
                                                     -boxcollider.size.z)*0.5f);
        
        vertices[4] =
            boxcollider.transform.TransformPoint(boxcollider.center +
                                                 new Vector3(boxcollider.size.x, boxcollider.size.y, boxcollider.size.z)*
                                                 0.5f);
        vertices[5] =
            boxcollider.transform.TransformPoint(boxcollider.center +
                                                 new Vector3(-boxcollider.size.x, boxcollider.size.y, boxcollider.size.z)*
                                                 0.5f);
        vertices[6] =
            boxcollider.transform.TransformPoint(boxcollider.center +
                                                 new Vector3(-boxcollider.size.x, boxcollider.size.y,
                                                     -boxcollider.size.z)*0.5f);
        vertices[7] =
            boxcollider.transform.TransformPoint(boxcollider.center +
                                                 new Vector3(boxcollider.size.x, boxcollider.size.y, -boxcollider.size.z)*
                                                 0.5f);

        return vertices;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity5.4 摄像机围绕物体旋转与方向操作]]></title>
        <id>https://bouvet1.github.io/post/unity54-she-xiang-ji-wei-rao-wu-ti-xuan-zhuan-yu-fang-xiang-cao-zuo</id>
        <link href="https://bouvet1.github.io/post/unity54-she-xiang-ji-wei-rao-wu-ti-xuan-zhuan-yu-fang-xiang-cao-zuo">
        </link>
        <updated>2017-07-04T06:16:29.000Z</updated>
        <content type="html"><![CDATA[<pre><code>public Transform target;//获取旋转目标

private void camerarotate() //摄像机围绕目标旋转操作
    {
        transform.RotateAround(target.position, Vector3.up, speed*Time.deltaTime); //摄像机围绕目标旋转
        var mouse_x = Input.GetAxis(&quot;Mouse X&quot;);//获取鼠标X轴移动
        var mouse_y = -Input.GetAxis(&quot;Mouse Y&quot;);//获取鼠标Y轴移动
        if (Input.GetKey(KeyCode.Mouse1))
        {
            transform.Translate(Vector3.left*(mouse_x*15f)*Time.deltaTime);
            transform.Translate(Vector3.up*(mouse_y*15f)*Time.deltaTime);
        }
        if (Input.GetKey(KeyCode.Mouse0))
        {
            transform.RotateAround(target.transform.position, Vector3.up, mouse_x*5);
            transform.RotateAround(target.transform.position, transform.right, mouse_y*5);
        }
    }

    private void camerazoom() //摄像机滚轮缩放
    {
        if (Input.GetAxis(&quot;Mouse ScrollWheel&quot;) &gt; 0)
            transform.Translate(Vector3.forward*0.5f);


        if (Input.GetAxis(&quot;Mouse ScrollWheel&quot;) &lt; 0)
            transform.Translate(Vector3.forward*-0.5f);
    }
</code></pre>
]]></content>
    </entry>
</feed>